<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Broadcaster</title>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
  </head>
  <body class="bg-slate-900 min-h-screen">
    <div
      x-data="broadcasterClient()"
      class="container mx-auto px-4 py-6 max-w-7xl"
    >
      <!-- Two Column Layout -->
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <!-- Left Column: Publishing -->
        <div class="space-y-6">
          <h1 class="text-2xl font-bold text-white">Publish Messages</h1>

          <!-- Publish Message Section -->
          <div class="bg-slate-800 border border-slate-700 rounded-lg p-6">
            <h2 class="text-lg font-medium text-white mb-4">Send Message</h2>
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  API Key
                </label>
                <input
                  x-model="apiKey"
                  type="text"
                  placeholder="your-api-key"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  Target Channel
                </label>
                <input
                  x-model="publishChannel"
                  type="text"
                  placeholder="Channel"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  Event
                </label>
                <input
                  x-model="publishEvent"
                  type="text"
                  placeholder="Event"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  Message Payload (JSON)
                </label>
                <textarea
                  x-model="messagePayload"
                  rows="8"
                  placeholder='{"message": "hello world"}'
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent font-mono"
                ></textarea>
              </div>
              <button
                @click="publishMessage()"
                :disabled="!publishChannel.trim() || !publishEvent.trim() || !messagePayload.trim() || publishing"
                class="w-full inline-flex items-center justify-center space-x-2 px-4 py-3 rounded-md font-medium text-white transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed bg-green-600 hover:bg-green-700"
              >
                <i data-lucide="send" class="w-4 h-4"></i>
                <span
                  x-text="publishing ? 'Publishing...' : 'Publish Message'"
                ></span>
              </button>
              <div
                x-show="publishStatus"
                class="p-3 rounded-md"
                :class="publishSuccess ? 'bg-green-900/50 border border-green-700 text-green-200' : 'bg-red-900/50 border border-red-700 text-red-200'"
              >
                <span x-text="publishStatus"></span>
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column: Listening -->
        <div class="space-y-6">
          <h1 class="text-2xl font-bold text-white">Listen to Messages</h1>

          <!-- Connection Panel -->
          <div class="bg-slate-800 border border-slate-700 rounded-lg p-6">
            <div class="flex items-center justify-between mb-4">
              <div class="flex items-center space-x-3">
                <div
                  class="w-3 h-3 rounded-full"
                  :class="connected ? 'bg-green-400' : authenticated ? 'bg-yellow-400' : 'bg-slate-500'"
                ></div>
                <span
                  class="text-lg font-medium text-white"
                  x-text="connected ? 'Connected' : authenticated ? 'Authenticated' : 'Disconnected'"
                ></span>
                <span x-show="connected" class="text-sm text-slate-400">
                  (<span x-text="channelId"></span>)
                </span>
              </div>
            </div>

            <div class="flex flex-col space-y-3">
              <div x-show="!connected && !authenticated">
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  User ID
                </label>
                <input
                  x-model="userId"
                  type="text"
                  placeholder="User ID"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <div x-show="!connected && !authenticated">
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  Authorized Channels (comma-separated)
                </label>
                <input
                  x-model="authorizedChannels"
                  type="text"
                  placeholder="chan1,chan2,chan3"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <div x-show="!connected && !authenticated">
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  JWT Secret (for demo purposes)
                </label>
                <input
                  x-model="jwtSecret"
                  type="text"
                  placeholder="your-secret-key"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <div x-show="authenticated && !connected">
                <label class="block text-sm font-medium text-slate-300 mb-2">
                  Channel to Listen
                </label>
                <input
                  x-model="channel"
                  type="text"
                  placeholder="Channel"
                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-white text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              <button
                @click="handleConnectionAction()"
                :disabled="(connected === false && authenticated === false && (!userId.trim() || !authorizedChannels.trim() || !jwtSecret.trim())) || (authenticated === true && connected === false && !channel.trim())"
                class="w-full inline-flex items-center justify-center space-x-2 px-4 py-3 rounded-md font-medium text-white transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
                :class="connected ? 'bg-red-600 hover:bg-red-700' : authenticated ? 'bg-blue-600 hover:bg-blue-700' : 'bg-green-600 hover:bg-green-700'"
              >
                <i
                  :data-lucide="connected ? 'unplug' : authenticated ? 'plug' : 'user-check'"
                  class="w-4 h-4"
                ></i>
                <span
                  x-text="connected ? 'Unsubscribe' : authenticated ? 'Subscribe' : 'Authenticate'"
                ></span>
              </button>
            </div>
          </div>

          <!-- Messages Section -->
          <div class="bg-slate-800 border border-slate-700 rounded-lg">
            <div class="px-6 py-4 border-b border-slate-700">
              <div class="flex items-center justify-between">
                <h2 class="text-lg font-medium text-white">
                  Received Messages
                </h2>
                <span
                  class="bg-slate-700 text-slate-300 px-2 py-1 rounded text-sm"
                  x-text="messages.length"
                ></span>
              </div>
            </div>

            <div class="p-6">
              <!-- Empty State -->
              <div x-show="messages.length === 0" class="text-center py-8">
                <i
                  data-lucide="inbox"
                  class="w-8 h-8 text-slate-500 mx-auto mb-2"
                ></i>
                <p class="text-slate-400">No messages yet</p>
              </div>

              <!-- Messages List -->
              <div
                x-show="messages.length > 0"
                class="space-y-3 max-h-96 overflow-y-auto"
              >
                <template
                  x-for="(message, index) in messages.slice().reverse()"
                  :key="message.id"
                >
                  <div
                    class="bg-slate-700/50 border border-slate-600 rounded-md p-4"
                  >
                    <div class="flex items-center justify-between mb-2">
                      <span class="text-sm font-medium text-slate-300">
                        Message #<span x-text="messages.length - index"></span>
                      </span>
                      <span
                        class="text-xs text-slate-500"
                        x-text="'ID: ' + message.id"
                      ></span>
                    </div>
                    <div
                      class="bg-slate-800 rounded border border-slate-600 p-3"
                    >
                      <pre
                        class="text-sm text-slate-300 font-mono whitespace-pre-wrap overflow-x-auto"
                        x-text="JSON.stringify(message.payload, null, 2)"
                      ></pre>
                    </div>
                  </div>
                </template>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      function broadcasterClient() {
        return {
          ws: null,
          connected: false,
          authenticated: false,
          messages: [],
          channel: "mychan",
          publishChannel: "mychan",
          publishEvent: "my-event",
          messagePayload: '{"message": "hello world"}',
          publishing: false,
          publishStatus: "",
          publishSuccess: false,
          userId: "user123",
          authorizedChannels: "mychan,otherchan",
          jwtSecret: "your-secret-key",
          apiKey: "test-api-key",
          requestId: 1,
          pendingRequests: new Map(),
          init() {
            this.$nextTick(() => lucide.createIcons());
          },

          handleConnectionAction() {
            if (this.connected) {
              this.unsubscribeFromChannel();
            } else if (this.authenticated) {
              this.subscribeToChannel();
            } else {
              this.authenticate();
            }
          },
          authenticate() {
            this.ws = new WebSocket(
              "ws://localhost:8000/broadcaster/websocket",
            );
            let pingInterval;

            this.ws.onmessage = (event) => {
              const message = JSON.parse(event.data);
              this.handleWebSocketMessage(message);
            };

            this.ws.onopen = () => {
              console.log("Connected to WebSocket server");
              this.$nextTick(() => lucide.createIcons());
              this.sendAuthentication();
            };

            this.ws.onclose = () => {
              console.log("Disconnected from WebSocket server");
              this.authenticated = false;
              this.connected = false;
              this.pendingRequests.clear();
              this.$nextTick(() => lucide.createIcons());

              if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
              }
            };

            this.ws.onerror = (error) => {
              console.error("WebSocket error:", error);
            };

            // Start heartbeat once authenticated and connected
            this.$watch("connected", (connected) => {
              if (connected && !pingInterval) {
                pingInterval = setInterval(() => {
                  this.sendRequest("heartbeat", null, true);
                }, 10000);
              }
            });
          },
          async sendAuthentication() {
            try {
              const authChannels = this.authorizedChannels
                .split(",")
                .map((ch) => ch.trim())
                .filter((ch) => ch);

              // Create JWT token using vanilla JavaScript
              const now = Math.floor(Date.now() / 1000);
              const payload = {
                sub: this.userId,
                authorizedChannels: authChannels,
                aud: "broadcaster",
                iat: now,
                exp: now + 3600, // 1 hour expiration
                scope: ["subscribe"],
              };

              const token = await this.createJWT(payload, this.jwtSecret);

              this.sendRequest("auth", {
                token: token,
              })
                .then((response) => {
                  if (response.error) {
                    console.error("Authentication failed:", response.error);
                    alert(`Authentication failed: ${response.error.message}`);
                    this.disconnect();
                  } else {
                    console.log("Authentication successful");
                    this.authenticated = true;
                    this.$nextTick(() => lucide.createIcons());
                  }
                })
                .catch((error) => {
                  console.error("Authentication error:", error);
                  alert(`Authentication error: ${error.message}`);
                  this.disconnect();
                });
            } catch (error) {
              console.error("JWT creation error:", error);
              alert(`JWT creation error: ${error.message}`);
              this.disconnect();
            }
          },
          async createJWT(payload, secret) {
            const header = {
              alg: "HS256",
              typ: "JWT",
            };

            const encodedHeader = this.base64UrlEncode(JSON.stringify(header));
            const encodedPayload = this.base64UrlEncode(
              JSON.stringify(payload),
            );

            const signatureInput = `${encodedHeader}.${encodedPayload}`;
            const signature = await this.hmacSha256(signatureInput, secret);
            const encodedSignature = this.base64UrlEncode(signature);

            return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
          },
          base64UrlEncode(data) {
            let bytes;
            if (typeof data === "string") {
              bytes = new TextEncoder().encode(data);
            } else {
              bytes = data;
            }

            const base64 = btoa(String.fromCharCode(...bytes));
            return base64
              .replace(/\+/g, "-")
              .replace(/\//g, "_")
              .replace(/=/g, "");
          },
          async hmacSha256(data, secret) {
            const encoder = new TextEncoder();
            const keyData = encoder.encode(secret);
            const dataBuffer = encoder.encode(data);

            const key = await crypto.subtle.importKey(
              "raw",
              keyData,
              { name: "HMAC", hash: "SHA-256" },
              false,
              ["sign"],
            );

            const signature = await crypto.subtle.sign("HMAC", key, dataBuffer);
            return new Uint8Array(signature);
          },

          subscribeToChannel() {
            if (!this.authenticated || !this.channel.trim()) {
              return;
            }

            const lastSeenMessageId = this.messages.length
              ? this.messages[this.messages.length - 1].id
              : "";

            this.sendRequest("subscribe", {
              channel: this.channel,
              lastSeenMessageId: lastSeenMessageId,
            })
              .then((response) => {
                if (response.error) {
                  console.error("Subscribe failed:", response.error);
                  alert(`Failed to subscribe to channel: ${response.error.message}`);
                } else {
                  console.log("Successfully subscribed to channel");
                  this.connected = true;

                  // Add history messages if any
                  if (response.result && response.result.history) {
                    this.messages.push(...response.result.history.reverse());
                  }

                  this.$nextTick(() => lucide.createIcons());
                }
              })
              .catch((error) => {
                console.error("Subscribe error:", error);
                alert(`Error subscribing to channel: ${error}`);
              });
          },
          unsubscribeFromChannel() {
            if (!this.connected) {
              return;
            }

            this.sendRequest("unsubscribe", {
              channel: this.channel,
            })
              .then((response) => {
                if (response.error) {
                  console.error("Unsubscribe failed:", response.error);
                  alert(`Failed to unsubscribe from channel: ${response.error.message}`);
                } else {
                  console.log("Successfully unsubscribed from channel");
                  this.connected = false;
                  this.messages = [];
                  this.$nextTick(() => lucide.createIcons());
                }
              })
              .catch((error) => {
                console.error("Unsubscribe error:", error);
                alert(`Error unsubscribing from channel: ${error}`);
              });
          },
          sendRequest(method, params, expectReply = true) {
            return new Promise((resolve, reject) => {
              if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                reject(new Error("WebSocket not connected"));
                return;
              }

              const request = {
                method: method,
                params: params,
              };

              if (expectReply) {
                request.id = this.requestId++;
                this.pendingRequests.set(request.id, {
                  resolve,
                  reject,
                  timestamp: Date.now(),
                });

                // Timeout after 30 seconds
                setTimeout(() => {
                  if (this.pendingRequests.has(request.id)) {
                    this.pendingRequests.delete(request.id);
                    reject(new Error("Request timeout"));
                  }
                }, 30000);
              } else {
                // For requests that don't expect a reply, resolve immediately
                resolve(null);
              }

              this.ws.send(JSON.stringify(request));
            });
          },
          handleWebSocketMessage(message) {
            // Handle notifications (broadcasts)
            if (message.method === "broadcast") {
              this.messages.push(message.params);
              return;
            }

            // Handle responses to requests
            if (
              message.requestId &&
              this.pendingRequests.has(message.requestId)
            ) {
              const { resolve } = this.pendingRequests.get(message.requestId);
              this.pendingRequests.delete(message.requestId);
              resolve(message);
              return;
            }

            console.log("Unhandled message:", message);
          },
          disconnect() {
            if (this.ws) {
              this.ws.close();
              this.ws = null;
            }
            this.authenticated = false;
            this.connected = false;
            this.pendingRequests.clear();
          },
          async publishMessage() {
            if (!this.publishChannel.trim() || !this.publishEvent.trim() || !this.messagePayload.trim()) {
              return;
            }

            this.publishing = true;
            this.publishStatus = "";

            try {
              // Validate JSON
              const payload = JSON.parse(this.messagePayload);

              const response = await fetch(
                "http://localhost:8000/broadcaster/publish",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${this.apiKey}`,
                  },
                  body: JSON.stringify({
                    channel: this.publishChannel,
                    event: this.publishEvent,
                    payload: payload,
                  }),
                },
              );

              if (response.ok) {
                this.publishStatus = `Message published successfully to channel "${this.publishChannel}"`;
                this.publishSuccess = true;
                // Clear the payload for next message
                this.messagePayload = '{"message": ""}';
              } else {
                const errorText = await response.text();
                this.publishStatus = `Failed to publish message: ${response.status} ${errorText}`;
                this.publishSuccess = false;
              }
            } catch (error) {
              if (error instanceof SyntaxError) {
                this.publishStatus = "Invalid JSON payload";
              } else {
                this.publishStatus = `Error: ${error.message}`;
              }
              this.publishSuccess = false;
            } finally {
              this.publishing = false;
              // Clear status after 5 seconds
              setTimeout(() => {
                this.publishStatus = "";
              }, 5000);
            }
          },
        };
      }
    </script>
    <script src="https://unpkg.com/lucide"></script>
    <script src="https://unpkg.com/alpinejs"></script>
  </body>
</html>